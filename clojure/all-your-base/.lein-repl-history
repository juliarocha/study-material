    (concat (from-decimal (int (/ num base)) base) (list (mod num base)))
    '(1)
    )
  )
(defn convert [base-inic list-numero base-final ] ;; <- arglist goes here
  ;; your code goes here
  (if (not-empty list-numero)
    (let [decimal
          (to-decimal list-numero base-inic)
          result
          (from-decimal decimal base-final)])
    '()
    )
)
(to-decimal '(1) 2)
(from-decimal 1 10)
(defn convert [base-inic list-numero base-final ] ;; <- arglist goes here
  ;; your code goes here
  (if (not-empty list-numero)
    (let [decimal
          (to-decimal list-numero base-inic)
          result
          (from-decimal decimal base-final)]
      result)
    '()
    )
)
(all-your-base/convert 2 '(1) 10)
(all-your-base/convert 2 '(1 0 1) 10)
(to-decimal '(1 0 1) 2)
(from-decimal 5 10)
(int (/ 5 10))
(list 5)
(list 43)
(defn- to-list [num]
  (for [digit num]
    (concat (list digit))
    )
  )
(to-list 5)
(list 5)
(defn- to-list [num]
  (for [digit num]
    (concat (list digit) '())
    )
  )
(to-list 5)
(defn- to-list [num]
  (for [digit num]
    (print digit)
    )
  )
(to-list 5)
(map 5)
(list (map 42))
(list (map "42"))
(map "42))
)
(map "42")
(/ 5 10)
(mod 5 10)
(/ 255 10)
(int (/ 255 10))
(int (/ 25 10))
(int (/ 2 10))
(defn- to-list [num]
  (if (= num 0)
    nil
    (concat (list (mod num 10)) (to-list (/ num 10))))
  )
(to-list 255)
(def num 255)
num
(mod num 10)
(list (mod num 10))
(/ num 10)
(int (/ num 10))
(defn- to-list [num]
  (if (= num 0)
    nil
    (concat (list (mod num 10)) (to-list (int (/ num 10)))))
  )
(to-list num)
(defn- to-list [num]
  (if (= num 0)
    nil
    (concat (to-list (int (/ num 10))) (list (mod num 10))))
  )
(to-list num)
(defn- from-decimal [num base]
  (if (= 10 base)
    (to-list num)
  (if (not= num 1)
    (concat (from-decimal (int (/ num base)) base) (list (mod num base)))
    '(1)
    )
  )
))
(defn- from-decimal [num base]
  (if (= 10 base)
    (to-list num))
  (if (not= num 1)
    (concat (from-decimal (int (/ num base)) base) (list (mod num base)))
    '(1)
    )
  )
(from-decimal 255 10)
(def base 10)
base
(= 10 base)
(defn- from-decimal [num base]
  (if (= 10 base)
    (to-list num)
    (if (not= num 1)
      (concat (from-decimal (int (/ num base)) base) (list (mod num base)))
      '(1)
      )
    )
  )
(drom-decimal num base)
(from-decimal num base)
(all-your-base/convert 2 '(1) 10)
(= '(1) (all-your-base/convert 2 '(1) 10))
(defn convert [base-inic list-numero base-final] ;; <- arglist goes here
  ;; your code goes here
  (if (or (not (< 1 base-inic))
          (not (< 1 base-final)))
    nil
    (if (not-empty list-numero)
      (let [decimal
            (to-decimal list-numero base-inic)
            result
            (from-decimal decimal base-final)]
        result)
      '()
      )
    )
)
(all-your-base/convert 10 '(7) 0)
(all-your-base/convert -2 '(1) 10)
(all-your-base/convert 2 '(1) -7)
(all-your-base/convert -2 '(1) -7)
(all-your-base/convert 2 '(1 0 1 0 1 0) 1)
(all-your-base/convert 1 () 10)
(all-your-base/convert 2 '(1 2 1 0 1 0) 10)
(filter (fn [x]
                    (< x (dec base-inic)))
)
(filter (fn [x] (< x (dec 2))) '(1 2 1 0 1 0))
(filter (fn [x] (> x (dec 2))) '(1 2 1 0 1 0))
(filter (fn [x] (> x (dec 2))) '(1 1 1 0 1 0))
(not-empty (filter (fn [x] (< x (dec 2))) '(1 2 1 0 1 0))))
(not-empty (filter (fn [x] (< x (dec 2))) '(1 2 1 0 1 0)))
(not-empty (filter (fn [x] (> x (dec 2))) '(1 2 1 0 1 0)))
(empty? (filter (fn [x] (> x (dec 2))) '(1 2 1 0 1 0)))
(not (empty? (filter (fn [x] (> x (dec 2))) '(1 2 1 0 1 0))))
(not (empty? (filter (fn [x] (or (pos? x) (> x (dec 2)))) '(1 2 1 0 1 0)))))
(not (empty? (filter (fn [x] (or (pos? x) (> x (dec 2)))) '(1 2 1 0 1 0))))
(not (empty? (filter (fn [x] (or (pos? x) (> x (dec 2)))) '(1 -2 1 0 1 0))))
(not (empty? (filter (fn [x] (or (pos? x) (> x (dec 2)))) '(1 1 1 0 1 0))))
(not (empty? (filter (fn [x] (or (not(pos? x)) (> x (dec 2)))) '(1 1 1 0 1 0))))
(not (empty? (filter (fn [x] (or (not(pos? x)) (> x (dec 2)))) '(1 1 -1 0 1 0))))
(filter (fn [x] (or (not (pos? x)) (> x (dec 2)))) '(1 1 -1 0 1 0))
(filter (fn [x] (or (not (<= 0 x)) (> x (dec 2)))) '(1 1 -1 0 1 0))
(filter (fn [x] (or (not (<= 0 x)) (> x (dec 2)))) '(1 1 2 0 1 0))
(all-your-base/convert 7 '(0 6 0) 10)
(all-your-base/convert 10 '(0 0 0) 2)
(defn- to-decimal [list-num base]
  (if (not-empty list-num)
    (+ (* (first list-num) (exp base (- (count list-num) 1))) (to-decimal (rest list-num) base))
    0
   )
  )
(all-your-base/convert 10 '(0) 2)
(to-decimal '(0) 10)
(to-decimal '(0) 2)
(to-decimal '(0) 4)
(from-decimal 0 4)
(defn- from-decimal [num base]
  (if (or (= 10 base) (= 0 num))
    (to-list num)
    (if (not= num 1)
      (concat (from-decimal (int (/ num base)) base) (list (mod num base)))
      '(1)
      )
    )
  )
(from-decimal 0 4)
(defn- from-decimal [num base]
  (if (= 10 base)
    (to-list num)
    (if (not= num 1)
      (concat (from-decimal (int (/ num base)) base) (list (mod num base)))
      '(1)
      )
    )
  )
(defn- from-decimal [num base]
  (if (= 10 base)
    (to-list num)
    ;(if (not= num 1)
      (concat (from-decimal (int (/ num base)) base) (list (mod num base)))
      ;'(1)
      ;)
    )
  )
(from-decimal 1 10)
(from-decimal 42 10)
(from-decimal 42 5)
(defn- from-decimal [num base]
  (if (= 10 base)
    (to-list num)
    (if (not= num 1)
      (concat (from-decimal (int (/ num base)) base) (list (mod num base)))
      '(1)
      )
    )
  )
(from-decimal 42 5)
(defn- from-decimal [num base]
  (if (= 10 base)
    (to-list num)
    (if (not= num 1)
      (if (= 0 num)
        '(0)
        (concat (from-decimal (int (/ num base)) base) (list (mod num base)))
        )
      '(1)
      )
    )
  )
(from-decimal
42 5)
(from-decimal 0 3)
(from-decimal 1 3)
(from-decimal 3 3)
(ns all-your-base)
(all-your-base/convert 3 '(1 1 2 0) 16)
(ns all-your-base)
(defn- exp [x n]
  (if (zero? n) 1
                (* x (exp x (dec n)))))
(defn- to-list [num]
  (if (= num 0)
    nil
    (concat (to-list (int (/ num 10))) (list (mod num 10))))
  )
(defn- to-decimal [list-num base]
  (if (not-empty list-num)
    (+ (* (first list-num) (exp base (- (count list-num) 1))) (to-decimal (rest list-num) base))
    0
   )
  )
(defn- from-decimal [num base]
  (if (= 10 base)
    (to-list num)
    (if (not= num 1)
      (if (= 0 num)
        '(0)
        (concat (from-decimal (int (/ num base)) base) (list (mod num base)))
        )
      '(1)
      )
    )
  )
(defn convert [base-inic list-numero base-final] ;; <- arglist goes here
  ;; your code goes here
  (if (or (not (< 1 base-inic))
          (not (< 1 base-final))
          (not (empty? (filter (fn [x] (or (not (<= 0 x)) (> x (dec base-inic)))) list-numero))))
    nil
    (if (not-empty list-numero)
      (let [decimal
            (to-decimal list-numero base-inic)
            result
            (from-decimal decimal base-final)]
        result)
      '()
      )
    )
)
(convert 3 '(1 1 2 0) 16)
(to-decimal '(1 1 2 0) 3)
(from-decimal 42 16)
(defn- from-decimal [num base]
  (if (= 10 base)
    (to-list num)
    (if (not= num 1)
      (if (= 0 num)
        ;'(0)
        (concat (from-decimal (int (/ num base)) base) (list (mod num base)))
        )
      '(1)
      )
    )
  )
(from-decimal 42 16)
(defn- from-decimal [num base]
  (if (= 10 base)
    (to-list num)
    (if (not= num 1)
      (if (= 0 num)
        ;'(0)
        ()
        (concat (from-decimal (int (/ num base)) base) (list (mod num base)))
        )
      '(1)
      )
    )
  )
(from-decimal 42 16)
(from-decimal 0 16)
(def num 42)
(def base 16)
(int (/ num base))
(list (mod num base))
(int (/ num base))
num
(> num 0)
(< num 0)
(defn- to-list [num]
  (if (> num 0)
    (concat (to-list (int (/ num 10))) (list (mod num 10))))
    '(0)
  )
(to-list 42)
(> num 0)
(defn- to-list [num]
  (if (> num 0)
    (concat (to-list (int (/ num 10))) (list (mod num 10)))
    '(0)
    )
  )
(to-list 42)
(defn- to-list [num]
  (if (> num 0)
    (concat (to-list (int (/ num 10))) (list (mod num 10)))
    '()
    )
  )
(to-list num)
(defn- to-list [num]
  (if (> num 0)
    (concat (to-list (int (/ num 10))) (list (mod num 10)))
    (if (= num 0)
      '(0)
      '())
    )
  )
(to-list 42)
(defn- to-list [num]
  (if (>= num 0)
    (concat (to-list (int (/ num 10))) (list (mod num 10)))
    '()
    )
  )
(to-list 42)
(defn- to-list [num]
  (if (> num 0)
    (concat (to-list (int (/ num 10))) (list (mod num 10)))
    '()
    )
  )
(to-list 42)
(to-list 0)
(defn- from-decimal [num base]
  (if (= 10 base)
    (to-list num)
    (if (not= num 1)
      (if (= 0 num)
        '(0)
        (concat (from-decimal (int (/ num base)) base) (list (mod num base)))
        )
      '(1)
      )
    )
  )
(from-decimal 42 5)
(from-decimal 0 5)
(all-your-base/convert 3 '(1 1 2 0) 16)
(from-decimal 42 16)
(defn- from-decimal [num base]
  (print "---" num base "n")
  (if (= 10 base)
    (to-list num)
    (if (not= num 1)
      (if (= 0 num)
        '(0)
        (concat (from-decimal (int (/ num base)) base) (list (mod num base)))
        )
      '(1)
      )
    )
  )
(from-decimal num 16)
(zero? '(0 0 0))
(defn- from-decimal [num base]
  (print "---" num base "n")
  (if (= 10 base)
    (to-list num)
    (if (not= num 1)
      (concat (from-decimal (int (/ num base)) base) (list (mod num base)))
      '(1)
      )
    )
  )
(from-decimal 42 16)
(defn- from-decimal [num base]
  (print "---" num base "n")
  (if (= 10 base)
    (to-list num)
    (if (not= num 1)
      (if (= 0 num)
        '()
        (concat (from-decimal (int (/ num base)) base) (list (mod num base)))
        )
      '(1)
      )
    )
  )
(from-decimal 42 16)
(every? zero? '(0 0 0))
(every? zero? '(0 0 2))
(every? zero? '(0 0 2(defn convert [base-inic list-numero base-final] ;; <- arglist goes here))
  ;; your code goes here
  (if (or (not (< 1 base-inic))
          (not (< 1 base-final))
          (not (empty? (filter (fn [x] (or (not (<= 0 x)) (> x (dec base-inic)))) list-numero))))
    nil
    (if (not-empty list-numero)
      (if (every? zero? list-numero)
        '(0)
        (let [decimal
              (to-decimal list-numero base-inic)
              result
              (from-decimal decimal base-final)]
          result)
        '()
        )
      )
    )
)
"
(defn convert [base-inic list-numero base-final] ;; <- arglist goes here
  ;; your code goes here
  (if (or (not (< 1 base-inic))
          (not (< 1 base-final))
          (not (empty? (filter (fn [x] (or (not (<= 0 x)) (> x (dec base-inic)))) list-numero))))
    nil
    (if (not-empty list-numero)
      (if (every? zero? list-numero)
        '(0)
        (let [decimal
              (to-decimal list-numero base-inic)
              result
              (from-decimal decimal base-final)]
          result)
        '()
        )
      )
    )
)
(defn convert [base-inic list-numero base-final] ;; <- arglist goes here
  ;; your code goes here
  (if (or (not (< 1 base-inic))
          (not (< 1 base-final))
          (not (empty? (filter (fn [x] (or (not (<= 0 x)) (> x (dec base-inic)))) list-numero))))
    nil
    (if (not-empty list-numero)
      (if (every? zero? list-numero)
        '(0)
        (let [decimal
              (to-decimal list-numero base-inic)
              result
              (from-decimal decimal base-final)]
          result)
        )
      '()
    )
  )
)
(ns bases)
(defn- from-decimal [num base]
  (if (= 10 base)
    (to-list num)
    (if (not= num 1)
        (concat (from-decimal (int (/ num base)) base) (list (mod num base)))
      '(1)
      )
    )
  )
(defn- to-list [num]
  (if (> num 0)
    (concat (to-list (int (/ num 10))) (list (mod num 10)))
    '()
    )
  )
(to-list 13445)
(to-list 000)
(to-list 045)
